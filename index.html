<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>주신의 흔적</title>
  <link rel="icon" href="https://lh3.googleusercontent.com/d/1r51_in8C0TKK-OqfrFtSfWw7kyHIO0z1" type="image/png">
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      background: #333;
      color: #fff;
    }
.page-title {
  position: fixed;
  top: 6px;
  left: 47.2%;
  transform: translateX(-50%);
  font-size: 24px;
  font-weight: bold;
  color: #fff;
  z-index: 1000;
  background: #333;
  padding: 10px 20px;
}

    /* 좌측 메뉴 */
    .sidebar {
      width: 200px;
 margin-top: 70px;
      background: #222;
      padding: 10px;
      box-sizing: border-box;
    }
    .sidebar button {
      display: block;
      width: 100%;
      margin-bottom: 8px;
      padding: 8px;
      background: #666;
      border: none;
      color: #fff;
      cursor: pointer;
    }
    .sidebar button:hover { background: #666; }

.link-button {
  display: inline-block;
  padding: 8px 12px;
  background-color: #666;   /* 회색 배경 */
  color: #fff;              /* 흰 글씨 */
  border-radius: 4px;
  text-decoration: none;    /* 밑줄 제거 */
  cursor: pointer;
  margin-left: 22px;        /* 왼쪽 여백 추가 */
}

.link-button:hover {
  background-color: #888;   /* 마우스 올렸을 때 조금 더 밝은 회색 */
}

    /* 지도 박스 */
.map-container {
  width: calc(100vw - 200px); /* 전체 너비 - 사이드바 */
  height: calc(100vh - 70px); /* 전체 높이 - 타이틀 */
  margin-top: 70px;
  overflow: hidden;
  position: relative;
  background: #777;
  touch-action: none;
  cursor: grab;
  border-left: 2px solid #666;
}


    .map-wrap {
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
    }
.map-wrap img {
  display: block;
  max-width: none;   /* 원본 크기 그대로 사용 */
  height: auto;
  user-select: none;
  pointer-events: none;
}

    .marker {
      position: absolute;
      transform: translate(-50%, -50%);
      width: 25px;
      height: 25px;
      background: url('https://cdn-icons-png.flaticon.com/512/190/190411.png') no-repeat center/contain;
      cursor: pointer;
    }
    /* 버튼을 박스 위 중앙에 */
    .controls {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      display: flex;
      gap: 8px;
    }
    .controls button {
      padding: 6px 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <!-- 상단 타이틀 -->
  <div class="page-title">오오 주신의 흔적이시여..</div>

  <!-- 좌측 메뉴 -->
  <div class="sidebar">
    <button data-map="map1">마족</button>
    <button data-map="map2">천족</button>
  <a href="https://tc-imba.com/aion2-interactive-map/?map=World_D_A" target="_blank" class="link-button">
    정확한 위치 보기
  </a>
  </div>

  <!-- 지도 영역 -->
  <div class="map-container" id="mapContainer">
    <div class="controls">
      <button id="resetMarkers">마커 초기화</button>
      <button id="resetView">뷰 초기화</button>
    </div>
    <div class="map-wrap" id="mapWrap">
      <img src="https://8upload.com/image/affccf32a5cf33e4/map.jpg" alt="지도" id="map">
    </div>
  </div>



  <script>
    const container = document.getElementById("mapContainer");
    const mapWrap = document.getElementById("mapWrap");
    const map = document.getElementById("map");
    const btnResetMarkers = document.getElementById("resetMarkers");
    const btnResetView = document.getElementById("resetView");
    const buttons = document.querySelectorAll(".sidebar button");

    // 지도 목록
    const maps = {
      map1: "https://8upload.com/image/affccf32a5cf33e4/map.jpg",
      map2: "https://8upload.com/image/cbf6676237e0dd4d/angel.jpg"
    };
    let currentMap = "map1";

    // 뷰 상태
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let dragStartX, dragStartY, lastX, lastY;
    let inputFromMarker = false;

    // 마커 저장/불러오기 (지도별 분리)
    function loadMarkers(mapId) {
      return JSON.parse(localStorage.getItem("map-markers-" + mapId)) || [];
    }
    function saveMarkers(mapId, markers) {
      localStorage.setItem("map-markers-" + mapId, JSON.stringify(markers));
    }

    // 마커 생성
    function createMarker(x, y) {
      const marker = document.createElement("div");
      marker.className = "marker";
      marker.style.left = x + "px";
      marker.style.top = y + "px";
      marker.dataset.x = String(x);
      marker.dataset.y = String(y);

      marker.addEventListener("mousedown", (e) => { e.stopPropagation(); inputFromMarker = true; });
      marker.addEventListener("touchstart", (e) => { e.stopPropagation(); inputFromMarker = true; }, { passive: false });

      marker.addEventListener("click", (e) => {
        e.stopPropagation();
        removeMarkerElement(marker);
      });
      marker.addEventListener("touchend", (e) => {
        e.stopPropagation();
        removeMarkerElement(marker);
      }, { passive: false });

      mapWrap.appendChild(marker);
    }

    function removeMarkerElement(marker) {
      const x = marker.dataset.x;
      const y = marker.dataset.y;
      marker.remove();
      let markers = loadMarkers(currentMap);
      markers = markers.filter(m => !(String(m.x) === x && String(m.y) === y));
      saveMarkers(currentMap, markers);
    }

    // 지도 전환
buttons.forEach(btn => {
  btn.addEventListener("click", () => {
    // 기존 마커 제거
    document.querySelectorAll(".marker").forEach(m => m.remove());

    // 지도 교체
    currentMap = btn.dataset.map;
    map.src = maps[currentMap];

    // 이미지가 로드된 후 경계 계산
    map.onload = () => {
      scale = 1;
      translateX = 0;
      translateY = 0;
      updateTransform();
      // 해당 지도 마커 복원
      loadMarkers(currentMap).forEach(m => createMarker(m.x, m.y));
    };
  });
});


    // 초기 로드 시 마커 복원
    loadMarkers(currentMap).forEach(m => createMarker(m.x, m.y));

    // PC: 마우스 휠 줌 (1~5배, 마우스 위치 기준)
    container.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = container.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const prevScale = scale;
      scale = e.deltaY < 0 ? scale * 1.1 : scale / 1.1;
      scale = Math.min(Math.max(scale, 0.2), 5);

      translateX = mouseX - (mouseX - translateX) * (scale / prevScale);
      translateY = mouseY - (mouseY - translateY) * (scale / prevScale);

      updateTransform();
    }, { passive: false });

    // PC: 드래그 이동 + 클릭 구분
    container.addEventListener("mousedown", (e) => {
      isDragging = false;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      lastX = e.clientX;
      lastY = e.clientY;
      inputFromMarker = false;
    });
    container.addEventListener("mousemove", (e) => {
      if (dragStartX == null) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      if (Math.abs(e.clientX - dragStartX) > 5 || Math.abs(e.clientY - dragStartY) > 5) {
        isDragging = true;
      }
      if (isDragging) {
        translateX += dx;
        translateY += dy;
        updateTransform();
      }
      lastX = e.clientX;
      lastY = e.clientY;
    });
    container.addEventListener("mouseup", (e) => {
      if (inputFromMarker) { cleanupPointerState(); return; }
      if (!isDragging) {
        const rect = container.getBoundingClientRect();
        const x = ((e.clientX - rect.left - translateX) / scale).toFixed(2);
        const y = ((e.clientY - rect.top - translateY) / scale).toFixed(2);
        createMarker(x, y);
        const markers = loadMarkers(currentMap);
        markers.push({x, y});
        saveMarkers(currentMap, markers);
      }
      cleanupPointerState();
    });

    // 모바일: 핀치 줌 + 드래그 + 탭 마커
    let lastTouchDist = null;
    let lastTouchMid = null;
    let touchStartX, touchStartY, touchMoved = false;

    container.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        lastX = touchStartX;
        lastY = touchStartY;
        touchMoved = false;
        inputFromMarker = false;
      } else if (e.touches.length === 2) {
        lastTouchDist = getTouchDist(e.touches);
        lastTouchMid = getTouchMid(e.touches);
      }
    }, { passive: false });

    container.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        const dx = e.touches[0].clientX - lastX;
        const dy = e.touches[0].clientY - lastY;
        if (Math.abs(e.touches[0].clientX - touchStartX) > 5 || Math.abs(e.touches[0].clientY - touchStartY) > 5) {
          touchMoved = true;
        }
        if (touchMoved) {
          translateX += dx;
          translateY += dy;
          updateTransform();
        }
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      } else if (e.touches.length === 2) {
        const newDist = getTouchDist(e.touches);
        const mid = getTouchMid(e.touches);

        const prevScale = scale;
        scale *= newDist / lastTouchDist;
        scale = Math.min(Math.max(scale, 1), 5);

        translateX = mid.x - (mid.x - translateX) * (scale / prevScale);
        translateY = mid.y - (mid.y - translateY) * (scale / prevScale);

        lastTouchDist = newDist;
        lastTouchMid = mid;
        updateTransform();
      }
    }, { passive: false });

    container.addEventListener("touchend", (e) => {
      if (inputFromMarker) { inputFromMarker = false; return; }
      // 한 손가락 탭으로 종료되고, 이동이 거의 없었다면 마커 생성
      if (e.touches.length === 0 && e.changedTouches.length === 1 && !touchMoved) {
        const rect = container.getBoundingClientRect();
        const x = ((e.changedTouches[0].clientX - rect.left - translateX) / scale).toFixed(2);
        const y = ((e.changedTouches[0].clientY - rect.top - translateY) / scale).toFixed(2);
        createMarker(x, y);
        const markers = loadMarkers(currentMap);
        markers.push({x, y});
        saveMarkers(currentMap, markers);
      }
    });

    // 유틸
    function getTouchDist(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }
    function getTouchMid(touches) {
      return { x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 };
    }
    function cleanupPointerState() {
      dragStartX = dragStartY = null;
      isDragging = false;
      inputFromMarker = false;
    }

    // 경계 클램프 + 변환 적용
    function updateTransform() {
      const containerRect = container.getBoundingClientRect();
      const img = mapWrap.querySelector("img");
      const naturalW = img.naturalWidth;
      const naturalH = img.naturalHeight;

      const mapWidth = naturalW * scale;
      const mapHeight = naturalH * scale;

      const minX = containerRect.width - mapWidth;
      const minY = containerRect.height - mapHeight;
      const maxX = 0;
      const maxY = 0;

      translateX = Math.min(Math.max(translateX, minX), maxX);
      translateY = Math.min(Math.max(translateY, minY), maxY);

      mapWrap.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    }

    // 초기화 버튼
    btnResetMarkers.addEventListener("click", () => {
      localStorage.removeItem("map-markers-" + currentMap);
      document.querySelectorAll(".marker").forEach(m => m.remove());
    });
    btnResetView.addEventListener("click", () => {
      scale = 1; translateX = 0; translateY = 0; updateTransform();
    });
  </script>
</body>
</html>
